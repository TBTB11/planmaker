# 開発ハンドブック — 非エンジニアのための外注レベル開発手順

このドキュメントは、非エンジニアがAIエンジニア（Claude等）と協働してプロダクト開発を行う際に、**外注先のエンジニアに匹敵する品質管理・プロセス管理**ができるようになるためのトレーニング資料です。

3部構成になっています。

| Part | 内容 | 対象場面 |
|------|------|---------|
| Part 1 | 1つの機能を開発するときの手順 | 毎回の開発サイクルで使う |
| Part 2 | プロジェクト全体の管理手順 | プロジェクト全期間を通して使う |
| Part 3 | セキュリティを担保する手順 | 全工程で常に意識する |

---

# Part 1: 1つの機能を開発するときの手順

機能開発は**7つのステップ**で進めます。毎回この手順を踏むことで、プロの開発フローを再現できます。

```
Step 1  要件の確認
  ↓
Step 2  ブランチ作成
  ↓
Step 3  AIへの実装指示
  ↓
Step 4  実装中の確認
  ↓
Step 5  コードレビュー
  ↓
Step 6  コミット & PR作成
  ↓
Step 7  マージ & クリーンアップ
```

---

## Step 1: 要件の確認 — 何を作るか明確にする

**目的**: 作るものを自分の言葉で説明できる状態にする。

### やること

1. **要件定義書を読む** — `docs/references/学習計画ツール_要件定義書_v1.2.md` の該当セクション
2. **開発ロードマップを読む** — 今どのフェーズのどのタスクに取り組むのか確認
3. **「何ができるようになるか」を一文で書く**

### チェックリスト

- [ ] この機能で**誰が**何を**できるようになるか**説明できる
- [ ] 関連する画面が**既存のどの画面の近くにあるか**わかっている
- [ ] 必要な**データ項目**（入力フィールド）が列挙できる
- [ ] **完了条件**が明確になっている（何ができたら「完成」か）

### 実例: Phase Bの授業記録機能

```
誰が: 講師が
何を: 毎回の授業後に3-5分で授業記録を入力
できること: 実施単元、理解度(1-5)、コメント、宿題、次回予定の記録
完了条件: 記録の入力・一覧表示・編集ができる
```

---

## Step 2: ブランチ作成 — 作業場所を用意する

**目的**: 本番環境（masterブランチ）を壊さずに、安全に作業する。

### AIへの指示

```
「masterブランチから feat/class-records というブランチを作成して切り替えてください」
```

### ブランチ命名規則

| プレフィックス | 用途 | 例 |
|-------------|------|-----|
| `feat/` | 新しい機能の追加 | `feat/class-records` |
| `fix/` | バグの修正 | `fix/date-display-error` |
| `refactor/` | 動作を変えない内部改善 | `refactor/curriculum-editor` |
| `docs/` | ドキュメントの追加・修正 | `docs/add-handbook` |

### 注意点

- **1ブランチ = 1機能**が原則。複数の機能を同じブランチに詰め込まない
- ブランチ名は**英語の小文字とハイフン**で書く（日本語やスペースは使わない）
- 作業を始める前に**masterが最新か確認**する（`git pull origin master`）

---

## Step 3: AIへの実装指示 — 良い指示を出す

**目的**: AIが一発で正しいコードを書ける確率を最大化する。

### 良い指示の構造

```
1. 背景（なぜこの機能が必要か）
2. 参照ドキュメント（要件定義書の何章を見るか）
3. 具体的な成果物（どんなファイルを作るか）
4. 制約条件（既存パターンに合わせる等）
```

### 良い指示の例

```
要件定義書2.4章の授業記録機能を実装してください。

背景: 講師が毎授業後に記録を入力する画面が必要です。

成果物:
- src/features/classRecords/ClassRecordForm.tsx（入力フォーム）
- src/features/classRecords/ClassRecordList.tsx（一覧表示）

制約:
- 既存のStudentRegistration.tsxと同じパターン（React Hook Form + Zod）を使用
- db.tsのClassRecordインターフェースに準拠
- StudentDetailのタブ「授業記録」に組み込む
```

### 悪い指示の例と改善

| 悪い指示 | 問題点 | 改善案 |
|---------|-------|-------|
| 「授業記録を作って」 | 何を指すか曖昧 | 「要件定義書2.4章に基づき、ClassRecordForm.tsxを作成して」 |
| 「かっこよくして」 | 主観的で再現性がない | 「shadcn/uiのCardコンポーネントで囲んで統一感を出して」 |
| 「全部作って」 | スコープが広すぎる | 「まずPhase B-2の授業記録フォームだけ作って」 |
| 「前と同じ感じで」 | 「前」が何か不明 | 「StudentRegistration.tsxと同じReact Hook Form + Zodパターンで」 |

### AIとのやり取りの進め方

1. **まず計画を立てさせる** — 「実装計画を立ててください」と言って、AIの理解を確認
2. **計画を承認してから実装** — 方向が間違っていたら、この段階で軌道修正
3. **小さく進める** — 一度に全部ではなく、1コンポーネントずつ確認しながら進める

---

## Step 4: 実装中の確認 — 壊れていないか都度チェック

**目的**: 問題を早期発見して手戻りを防ぐ。

### 確認コマンド

```bash
# TypeScriptのエラーがないか確認（最重要）
npm run build

# 開発サーバーを起動して画面で確認
npm run dev
```

### 確認のタイミング

- AIが「完了しました」と言ったら**毎回** `npm run build` を実行
- 画面に関わる変更の場合は**ブラウザでも確認**
- エラーが出たらAIにエラーメッセージをそのまま伝える

### 画面確認チェックリスト

- [ ] ページが表示される（白画面にならない）
- [ ] ボタンをクリックして正しく動作する
- [ ] 入力フォームにデータを入力して保存できる
- [ ] 保存したデータが一覧に表示される
- [ ] ブラウザを更新してもデータが残っている（IndexedDBに保存されている）
- [ ] 他の画面が壊れていない（サイドバーのリンクをひととおりクリック）

---

## Step 5: コードレビュー — 非エンジニアでも見るべきポイント

**目的**: 品質上の問題を本番に入れる前に発見する。

### 非エンジニアでもチェックできる5つの観点

#### 1. ファイル数と場所が適切か

```
確認: 新しいファイルが src/features/[機能名]/ フォルダに入っているか
NG例: src/ 直下に雑にファイルが置かれている
```

#### 2. 日本語テキストが正しいか

```
確認: ボタンのラベル、エラーメッセージ、プレースホルダーが自然な日本語か
NG例: 「Student Registration」のような英語がUIに残っている
```

#### 3. 既存のパターンに合っているか

```
確認: 既存コンポーネント（StudentRegistration等）と似た構造になっているか
NG例: 既存はshadcn/uiのCardなのに、新画面だけdiv+独自CSSになっている
```

#### 4. 不要なコードがないか

```
確認: console.log、コメントアウトされたコード、テスト用のハードコード値
NG例: console.log("debug: ここ通った") が残っている
```

#### 5. エラーハンドリングがあるか

```
確認: データ保存時にtry-catchで囲まれているか
NG例: awaitだけあってエラー時の処理がない
```

### AIに確認させる方法

```
「今の変更内容をレビューしてください。以下を確認してください：
- 未使用のimportやconsole.logが残っていないか
- エラーハンドリングが適切か
- 既存コンポーネントとパターンが統一されているか」
```

---

## Step 6: コミット & PR作成 — 変更を記録する

**目的**: 変更履歴を残し、チームレビューの仕組みを作る。

### AIへの指示

```
「変更をコミットしてGitHubにPRを作成してください」
```

### コミットメッセージの書き方

良いコミットメッセージは「何を」「なぜ」変更したかがわかるものです。

```
良い例:
  Add class record form with validation
  Fix date display showing wrong timezone
  Refactor CurriculumEditor to accept props

悪い例:
  fix
  update
  作業中
```

### PR（Pull Request）で確認すべきこと

- **タイトル**: 何を変更したかが一目でわかる
- **変更ファイル数**: 多すぎないか（1機能で20ファイル以上は要注意）
- **差分の内容**: GitHubのFiles changedタブで赤（削除）と緑（追加）を見る

---

## Step 7: マージ & クリーンアップ — 完了処理

**目的**: 完成した機能を本番に反映し、作業場所を片付ける。

### AIへの指示

```
「PRをマージして、ローカルのmasterを最新にしてください。
 作業ブランチ feat/class-records は削除してください」
```

### マージ後のチェック

- [ ] `npm run build` がmasterブランチで成功する
- [ ] `npm run dev` で画面が正常に動く
- [ ] 開発ロードマップの該当タスクに完了マークをつける

---

# Part 2: プロジェクト全体の管理手順

1機能の開発手順（Part 1）を繰り返しながら、プロジェクト全体を管理するための手順です。

---

## 2-1. フェーズ管理

### フェーズとは

大きな機能群を「フェーズ」として区切り、段階的に開発を進めます。

```
Phase A: 基盤 + 生徒詳細 ← 完了
Phase B: 授業記録 + スケジュール ← 次はここ
Phase C: 進捗追跡 + アラート
Phase D: データ管理 + 出力
```

### フェーズ開始時にやること

1. **ゴール確認** — このフェーズで何が使えるようになるか
2. **依存関係確認** — 前フェーズの完了が前提か
3. **タスク分解** — フェーズ内のタスクを洗い出す（Part 1の手順を何回繰り返すか）

### フェーズ完了時にやること

1. **全画面の動作確認** — 新機能だけでなく、既存機能が壊れていないか
2. **ドキュメント更新** — 進捗サマリーの更新
3. **次フェーズの計画見直し** — 開発中に出た知見で計画を調整

---

## 2-2. バージョン管理の考え方

### バージョン番号の読み方

`v0.1.0` のような3つの数字は以下の意味を持ちます。

```
v [メジャー] . [マイナー] . [パッチ]
v     0     .     1      .    0

メジャー: 大きな変更（互換性のない変更）
マイナー: 機能追加
パッチ:   バグ修正
```

### PlanMakerでの目安

| バージョン | 状態 |
|-----------|------|
| v0.1.0 | Phase A完了（現在） |
| v0.2.0 | Phase B完了 |
| v0.3.0 | Phase C完了 |
| v0.4.0 | Phase D完了 |
| v1.0.0 | 講師が日常利用できる最初のリリース |

---

## 2-3. ドキュメントの維持管理

### ドキュメント一覧と更新タイミング

| ドキュメント | 場所 | 更新タイミング |
|------------|------|-------------|
| 要件定義書 | `docs/references/` | 要件変更時 |
| 技術スタック | `docs/planning/01_TECH_STACK.md` | ライブラリ追加時 |
| データモデル | `docs/planning/02_DATA_MODEL.md` | テーブル追加・変更時 |
| 開発ロードマップ | Claude計画ファイル | フェーズ開始/完了時 |
| 進捗サマリー | `docs/handbook/01_*.md` | フェーズ完了時 |

### ドキュメントが古くなるサイン

- コードの実装とドキュメントの記述が食い違っている
- 「TODO」「後で書く」が残ったまま
- 新しい機能がドキュメントに反映されていない

---

## 2-4. 技術的負債の管理

### 技術的負債とは

「今は動くけど、将来問題になりそうなコード」のことです。借金と同じで、放置すると利息（修正コスト）が膨らみます。

### よくある技術的負債の例

| 種類 | 具体例 | リスク |
|------|-------|-------|
| `as any` の使用 | 型チェックを無効化 | バグを見逃す |
| ハードコードされた値 | `"数学"` が直接書かれている | 変更時に漏れる |
| コピペコード | 同じロジックが複数箇所に | 修正漏れ |
| TODO/FIXMEコメント | 「後で直す」と書いてあるが直されていない | 問題が蓄積 |

### 管理方法

1. **発見したら記録する** — コード内に `// TODO:` コメントを残す
2. **フェーズ切り替え時に棚卸し** — TODOコメントを一括検索して対応を判断
3. **定期的にAIに聞く** — 「このプロジェクトにas anyの使用箇所はありますか？」

---

## 2-5. 依存パッケージの管理

### package.jsonの読み方

```json
{
  "dependencies": {     // 本番で使うライブラリ
    "react": "^18.3.1"  // ライブラリ名: バージョン
  },
  "devDependencies": {  // 開発時のみ使うツール
    "typescript": "^5.5.3"
  }
}
```

### パッケージ追加時の確認事項

新しいライブラリを追加する前に確認すること:

- [ ] **本当に必要か** — 既存ライブラリで代替できないか
- [ ] **メンテナンスされているか** — GitHubの最終更新日を確認（1年以上前は注意）
- [ ] **利用者数は十分か** — npmの週間ダウンロード数を確認
- [ ] **ライセンスは問題ないか** — MIT, Apache-2.0 は安全。GPL は要注意

### AIに確認させる方法

```
「〇〇というライブラリを追加したいのですが、このプロジェクトに適しているか
 確認してください。ライセンス、メンテナンス状況、代替手段も教えてください」
```

---

# Part 3: セキュリティを担保する手順

PlanMakerは**生徒の個人情報**を扱うアプリです。セキュリティは「できたらやる」ではなく「常に必ずやる」ものです。

---

## 3-1. ローカルファーストの意味

### PlanMakerのセキュリティの根幹

```
データは全てブラウザ内（IndexedDB）に保存される
  ↓
外部サーバーにデータを送信しない
  ↓
インターネット上にデータが漏洩するリスクが低い
```

### この設計で守られていること

- 生徒の名前、成績はブラウザの外に出ない
- サーバーがハッキングされてデータ漏洩、というリスクがない
- インターネット接続なしでも使える

### この設計で守れないこと（別の対策が必要）

- PC自体が盗まれた場合 → OSレベルの暗号化（BitLocker等）
- ブラウザの開発者ツールからの直接アクセス → 利用者教育
- データのバックアップ → エクスポート機能（Phase Dで実装）

---

## 3-2. 個人情報保護チェックリスト

### 開発中に毎回確認すること

#### コードレベル

- [ ] **console.logに個人情報を出力していないか**
  ```
  NG: console.log(student.name, student.grade)
  OK: console.log("Student loaded:", student.id)
  ```

- [ ] **エラーメッセージに個人情報が含まれていないか**
  ```
  NG: alert(`${student.name}の登録に失敗しました`)
  OK: alert("登録に失敗しました")
  ```

- [ ] **URLに個人情報が含まれていないか**
  ```
  NG: /students/yamada-taro
  OK: /students/uuid-xxxx-xxxx（ID参照）
  ```

#### データエクスポート時（Phase D以降）

- [ ] エクスポートファイルに匿名化オプションがあるか
- [ ] 匿名化時に名前が除去されているか
- [ ] エクスポート先のファイルパスをユーザーが選択できるか

---

## 3-3. 依存パッケージのセキュリティ

### npm auditの使い方

```bash
# セキュリティ脆弱性をチェック
npm audit

# 結果の見方
# 「moderate」は注意、「high」「critical」は即対応
```

### AIへの指示

```
「npm auditを実行して、セキュリティの問題があれば報告してください。
 highまたはcriticalがあれば対応してください」
```

### 新しいパッケージ追加前のチェック

```
「〇〇パッケージを追加する前に、以下を確認してください：
 1. 既知のセキュリティ脆弱性がないか
 2. 最新版が使われるか
 3. 不要な依存パッケージが大量に含まれていないか」
```

---

## 3-4. 秘密情報の管理

### 守るべきルール

| ルール | 理由 |
|-------|------|
| APIキーをコードに書かない | GitHubにpushすると全世界に公開される |
| .envファイルをGitに含めない | .gitignoreに記載されているか確認 |
| 認証情報をコミットしない | 一度pushすると履歴から完全に消すのが困難 |

### 現在のPlanMakerでの状況

PlanMakerはローカルファーストで外部APIを使わないため、現時点でAPIキーは不要です。ただし、将来AI機能を追加する際にはAPIキー管理が必要になります。

### .gitignoreの確認

以下がGitの追跡対象外になっていることを確認してください:

```
.env
.env.local
.env.test
node_modules/
```

AIへの確認指示:
```
「.gitignoreに.envファイルが含まれているか確認してください」
```

---

## 3-5. コードレビュー時のセキュリティ観点

### 非エンジニアでもチェックできるセキュリティ項目

#### 1. 外部通信をしていないか

```
チェック方法: AIに「fetch、axios、XMLHttpRequest の使用箇所を検索して」と指示
期待結果: PlanMakerでは外部APIへの通信が発生しないこと
```

#### 2. ユーザー入力をそのまま表示していないか（XSS防止）

```
チェック方法: AIに「dangerouslySetInnerHTML の使用箇所を検索して」と指示
期待結果: この関数が使われていないこと（Reactは標準でXSSを防止する）
```

#### 3. 個人情報がログに出力されていないか

```
チェック方法: AIに「console.log の使用箇所を全て見せて」と指示
期待結果: 生徒名や成績がconsole.logに含まれていないこと
```

#### 4. データの保存先が正しいか

```
チェック方法: AIに「localStorage、sessionStorage の使用箇所を検索して」と指示
期待結果: 個人情報はDexie（IndexedDB）のみに保存されていること
          localStorageにはUI設定のみ（あれば）
```

---

## まとめ: 毎回の開発で使うクイックリファレンス

### 開発開始前

```
□ 要件を確認して、作るものを一文で説明できるか
□ masterが最新か（git pull）
□ ブランチを作成したか
```

### 開発中

```
□ AIへの指示に「背景」「参照先」「成果物」「制約」を含めたか
□ npm run build でエラーが出ていないか
□ ブラウザで画面確認したか
□ 既存画面が壊れていないか
```

### 開発完了時

```
□ console.logが残っていないか
□ 個人情報がログやURLに含まれていないか
□ コミットメッセージが「何を」「なぜ」変更したか説明しているか
□ PRを作成したか
□ マージ後にmasterでビルドが通るか
```

### フェーズ完了時

```
□ 全画面の動作確認
□ npm audit でセキュリティチェック
□ ドキュメントの更新
□ 次フェーズの計画見直し
□ 技術的負債の棚卸し（TODO検索）
```
